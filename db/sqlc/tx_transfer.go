package db

import "context"

// neccessary input param for transfer transaction
type TranferTxParams struct {
	FromAccountID int64 `json:"from_account_id"`
	ToAccountID   int64 `json:"to_account_id"`
	Amount        int64 `json:"amount"`
}

type TransferTxResult struct {
	Transfer    Transfer `json:"transfer"`
	FromAccount Account  `json:"from_account"`
	ToAccount   Account  `json:"to_account"`
	FromEntry   Entry    `json:"from_entry"`
	ToEntry     Entry    `json:"to_entry"`
}

/*
problem and solution

1. concurrent transaction causing updates to be unequal - solve by having a FOR UPDATE lock
2. locking may cause deadlock (tx 1 depends on tx2 and vice verse) - solve by using NO KEY - allow concurrent transaction that does use the KEY COLUMN in their operations
  - mainly to allow INSERT into TRANSFER (FK contrains block acc table) and SELECT FOR UDPATE needing to lock, now allowing them to run concurrently as we guarantee the key won't be changed
  - LOCK by TX updates are still working

3. Pairwise transaction deadlock (ie tx1 -> tx2, tx2 -> tx1 concurrent), solved by allowing smaller account id to run first (deadlock won't occur)
*/
func (store *SQLStore) TransferTx(ctx context.Context, arg TranferTxParams) (TransferTxResult, error) {
	var result TransferTxResult

	err := store.execTx(ctx, func(q *Queries) error {
		var err error
		// txName := ctx.Value(txKey)

		// fmt.Println(txName, "create transfer")
		result.Transfer, err = q.CreateTransfer(ctx, CreateTransferParams{
			FromAccountID: arg.FromAccountID,
			ToAccountID:   arg.ToAccountID,
			Amount:        arg.Amount,
		})
		if err != nil {
			return err
		}

		// fmt.Println(txName, "create entry 1")
		result.FromEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.FromAccountID,
			Amount:    -arg.Amount,
		})
		if err != nil {
			return err
		}

		// fmt.Println(txName, "create entry 2")
		result.ToEntry, err = q.CreateEntry(ctx, CreateEntryParams{
			AccountID: arg.ToAccountID,
			Amount:    arg.Amount,
		})
		if err != nil {
			return err
		}

		// lock to prevent other transactions interfering with current operations
		// always need to acquire the lock of smaller account ID first
		// fmt.Println(txName, "update account 1")
		if arg.FromAccountID < arg.ToAccountID {
			result.FromAccount, result.ToAccount, err = addMoney(ctx, q, arg.FromAccountID, -arg.Amount, arg.ToAccountID, arg.Amount)
		} else {
			result.ToAccount, result.FromAccount, err = addMoney(ctx, q, arg.ToAccountID, arg.Amount, arg.FromAccountID, -arg.Amount)
		}
		if err != nil {
			return err
		}

		return nil // base case
	})

	return result, err
}
